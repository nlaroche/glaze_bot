# GlazeBot

## What This Is

GlazeBot is a platform for generating and managing AI personalities that provide live gaming commentary. Users collect characters through a gacha system (booster packs with rarity tiers), build parties of up to 3, and those characters watch gaming sessions via screen share and commentate in real time.

### How It Works
1. **Portal** (`app.glazebot.gg`) — Role-based web app. Users: manage subscription, download desktop app, check balance. Admins: dev tools for managing users, packs, integrations, variables, analytics, gacha config, and test character generation. Most user-facing functionality lives in the Tauri app, not the portal.
2. **Desktop app** (Tauri v2) — Screen shares the user's game, captures audio (VAD + STT), sends frames + transcript to the AI, plays back commentary (TTS). The Rust backend handles the real-time pipeline: screen capture → vision LLM (Dashscope Qwen VL) → text response → TTS (Fish Audio) → audio playback
3. **Discord bot** — Joins voice channels, same commentary pipeline but over Discord audio

### Architectural Decisions
- **Gacha system** for character acquisition — characters are AI-generated via Dashscope, not hand-crafted. Rarity affects personality depth and prompt quality.
- **Dual LLM provider** — Dashscope (Qwen VL) for vision + generation, Anthropic (Claude) as fallback
- **TTS: Fish Audio** — replaced ElevenLabs. Voice assigned randomly from user's Fish Audio library at character creation.
- **Real-time pipeline lives in Rust** (Tauri commands) — not in TypeScript. The SvelteKit frontend is UI only. STT, TTS, VAD, screen capture are all Rust-side.
- **Supabase for everything server-side** — auth, database, edge functions, storage. No custom backend.
- **Characters have `system_prompt`** — this is the core of the personality. It's generated by the LLM and stored in the DB. The desktop app uses it as the system prompt when the character commentates.

## Project Structure

Monorepo using pnpm workspaces + Turborepo.

### Apps
- `apps/desktop` — Tauri v2 + SvelteKit (static adapter), Rust backend
- `apps/discord-bot` — discord.js gateway bot, TypeScript
- `apps/marketing` — SvelteKit + Cloudflare Pages (`glazebot.gg`)
- `apps/portal` — SvelteKit + Cloudflare Pages (`app.glazebot.gg`)

### Packages
- `@glazebot/shared-types` — Character, Personality, Provider interfaces, DB types
- `@glazebot/shared-ui` — Shared Svelte 5 components (cards, modals, buttons)
- `@glazebot/shared-utils` — LLM prompt builder, provider registry, character loading
- `@glazebot/supabase-client` — Client factory with staging/prod switching

### Infrastructure
- `supabase/migrations/` — Database migrations (applied via CI, never manually)
- `supabase/functions/` — Edge functions (deployed via CI, never manually)
- `secrets/` — Git submodule pointing to `nlaroche/glazebot-secrets` (private, SOPS-encrypted)

## Branches & Environments

- `main` → production (Supabase project `tspalglvgypdktuhgqtf`, us-west-2)
- `develop` → staging (Supabase project `zwpwjceczndedcoegerx`, us-east-1)

## Secrets & Security — CRITICAL RULES

All secrets live in the `nlaroche/glazebot-secrets` repo, encrypted with SOPS + age.

### How secrets flow
1. SOPS files: `secrets/secrets.staging.yaml`, `secrets/secrets.production.yaml`
2. Local dev: `secrets/scripts/sync-env.sh` decrypts to `.env.staging` / `.env.production`
3. CI: `deploy-supabase.yml` decrypts SOPS, iterates ALL keys, pushes to Supabase via `supabase secrets set`, removes stale ones
4. GitHub Actions secrets (`SOPS_AGE_KEY`, `SUPABASE_ACCESS_TOKEN`, `SECRETS_REPO_SSH_KEY`, `SUPABASE_DB_PASSWORD_*`) are infrastructure-only — they let CI run, they don't contain app secrets

### Rules — NO EXCEPTIONS
- **NEVER set secrets manually** — not via dashboard, CLI, MCP, or any other method. Fix the CI pipeline instead.
- **NEVER hardcode secret names in CI workflows** — the deploy workflow iterates the SOPS yaml dynamically. Adding a secret to SOPS is enough.
- **NEVER read or log individual secret values** — treat them as opaque.
- **NEVER apply migrations via MCP `apply_migration` or `execute_sql`** — create files in `supabase/migrations/` and deploy through CI.
- **NEVER deploy edge functions via MCP** — push to the branch and CI handles it.

## Database Schema

Tables (all have RLS enabled):
- `characters` — id (uuid), user_id, name, description, backstory, system_prompt, personality (jsonb), rarity (enum: common/rare/epic/legendary), voice_id, voice_name, avatar_seed, created_at
- `booster_packs` — id (uuid), user_id, opened_at, character_ids (uuid[])
- `parties` — id (uuid), user_id, name, member_ids (uuid[], max 3), is_active, created_at, updated_at
- `gacha_config` — id (text, default 'default'), config (jsonb), updated_at
- `users` — id (uuid, FK to auth.users), discord_id, display_name, avatar_url

RPC: `daily_pack_count(p_user_id uuid)` → integer

## Edge Functions

- `open-booster-pack` — Rolls rarities, calls `generate-character` for each card, records pack, returns characters + remaining packs
- `generate-character` — Calls Dashscope (Qwen) to generate a character, assigns Fish Audio voice, inserts into DB
- `update-gacha-config` — Admin-only config update

## Shared UI Patterns

- Svelte 5 with runes (`$state`, `$derived`, `$effect`)
- Components in `@glazebot/shared-ui` are used by both portal and desktop
- Test IDs: all interactive elements use `data-testid` attributes for E2E testing
- Auth: PKCE OAuth + email OTP, session stored in localStorage as `sb-{PROJECT_REF}-auth-token`

## Service Layer

- `@glazebot/supabase-client` provides `createSupabaseClient()` that auto-switches between staging/prod based on `VITE_SUPABASE_URL`
- Portal pages fetch data via Supabase JS client (PostgREST for tables, `.rpc()` for functions, `functions.invoke()` for edge functions)
- RLS enforces all access control — users can only see/modify their own data
- Edge functions use service role client internally to bypass RLS for cross-user operations

## Testing

- Unit tests: Vitest (`apps/portal/tests/`)
- Schema validation: Vitest against real staging (`apps/portal/tests/integration/schema-validation.test.ts`)
- E2E: Playwright (`apps/portal/e2e/`)
  - Real auth fixture (`auth.fixture.ts`) — real Supabase sessions, no mocks
  - Mock auth fixture (`auth.fixture.mock.ts`) — for error-handling and slow-api tests only
  - Global setup seeds test data, global teardown cleans up
  - Edge functions that call paid AI APIs are mocked; everything else hits real staging

## ALWAYS

- Run tests after changes — execute them, read output, fix failures, repeat until green
- Push through CI/CD — never take local shortcuts
- Keep SOPS as single source of truth for all secrets
